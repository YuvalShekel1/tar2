package tree;

//מחלקה שבאמצעותה בונים עץ לשמירת מחרוזות ובה כל קודקוד מכיל מערך מצביעים לילדים בגודל 26 ומשתנה שמכיל את מספר הפעמים שהמחרוזת מופיעה בעץ 
public class Node {
	private int count; //מספר הפעמים שהמחרוזת המתוארת ע"י המסלול מהשורש עד לקודקוד זה הוכנסה לעץ.
	private Node[] children; //מערך המצביעים לילדים. אורכו הוא 1 + 'z' - 'a'.
	
	public Node() {//בנאי ללא פרמטרים 
		children=new Node[26]; //איתחול מערך מצביעים לילדים בגודל 26 בהתאם למספר האותיות
	}
	//מחזירה את מספר הפעמים שהמחרוזת נמצאת בעץ כאשר חושבים על הקודקוד הנוכחי בתור השורש
	public int num(String s) {
	     Node tmp=this; //משתנה עזר לאובייקט שעובדים עליו עכשיו
		 for(int i=0;i<s.length();i++) { //לולאה שעוברת אות אות מתחילת המחרוזת ובודקת אם קיים לה מצביע
			 if (tmp.children[s.charAt(i)-97]==null){ // תנאי שבודק בעזרת טבלת האסקי אם לא קיים מצביע במקום המתאים לאות
				 return 0; }
			 else {
			   tmp=tmp.children[s.charAt(i)-97];}} //אם קיים מצביע במקום המתאים לאות אז האובייקט שלנו יהיה האובייקט "שהאות" מצביעה עליו
		 return tmp.count; } //מחזיר את כמות הפעמים שהמחרוזת מופיעה
	
	//מוסיפה את המחרוזת לעץ, כאשר הקודקוד הנוכחי נחשב השורש
	public void add(String s) {
		if (s.length()>=1) { //תנאי שבודק שהמחרוזת לא ריקה או שהגענו לסוף המחרוזת שלנו
			if (this.children[s.charAt(0)-97]==null) { // תנאי שבודק אם קיים במערך הילדים מצביע לאובייקט במקום של האות הראשונה במחרוזת
				this.children[s.charAt(0)-97]=new Node();} //במידה ולא קיים מצביע לאובייקט אז ניצור אובייקט חדש כך שהמצביע יצביע עליו
			this.children[s.charAt(0)-97].add(s=s.substring(1)); //נפעיל ברקורסיה את הפונקציה כל פעם על המחרוזת החדשה פחות האות הראשונה
		}
		
		else {	count=this.count+1;} //בסיום טיפול באות האחרונה במחרוזת נעלה את המשתנה ב1
	}

}
